-- Generated by PeakRDL-regblock-vhdl - A free and open-source VHDL generator
--  https://github.com/SystemRDL/PeakRDL-regblock-vhdl
library ieee;
context ieee.ieee_std_context;
use ieee.fixed_pkg.all;

use work.CsrRegisters_pkg.all;
use work.reg_utils.all;

entity CsrRegisters is
    port (
        clk : in std_logic;
        rst : in std_logic;

        s_cpuif_req : in std_logic;
        s_cpuif_req_is_wr : in std_logic;
        s_cpuif_addr : in std_logic_vector(13 downto 0);
        s_cpuif_wr_data : in std_logic_vector(31 downto 0);
        s_cpuif_wr_biten : in std_logic_vector(31 downto 0);
        s_cpuif_req_stall_wr : out std_logic;
        s_cpuif_req_stall_rd : out std_logic;
        s_cpuif_rd_ack : out std_logic;
        s_cpuif_rd_err : out std_logic;
        s_cpuif_rd_data : out std_logic_vector(31 downto 0);
        s_cpuif_wr_ack : out std_logic;
        s_cpuif_wr_err : out std_logic;

        hwif_in : in CsrRegisters_in_t;
        hwif_out : out CsrRegisters_out_t
    );
end entity CsrRegisters;

architecture rtl of CsrRegisters is
    ----------------------------------------------------------------------------
    -- CPU Bus interface signals
    ----------------------------------------------------------------------------
    signal cpuif_req : std_logic;
    signal cpuif_req_is_wr : std_logic;
    signal cpuif_addr : std_logic_vector(13 downto 0);
    signal cpuif_wr_data : std_logic_vector(31 downto 0);
    signal cpuif_wr_biten : std_logic_vector(31 downto 0);
    signal cpuif_req_stall_wr : std_logic;
    signal cpuif_req_stall_rd : std_logic;

    signal cpuif_rd_ack : std_logic;
    signal cpuif_rd_err : std_logic;
    signal cpuif_rd_data : std_logic_vector(31 downto 0);

    signal cpuif_wr_ack : std_logic;
    signal cpuif_wr_err : std_logic;

    signal cpuif_req_masked : std_logic;

    

    ----------------------------------------------------------------------------
    -- Address Decode Signals
    ----------------------------------------------------------------------------
    type decoded_reg_strb_t is record
        mstatus : std_logic;
        misa : std_logic;
        medeleg : std_logic;
        mideleg : std_logic;
        mie : std_logic;
        mtvec : std_logic;
        mcounteren : std_logic;
        mstatush : std_logic;
        medelegh : std_logic;
        mvendorid : std_logic;
        marchid : std_logic;
        mimpid : std_logic;
        mhartid : std_logic;
        mconfigptr : std_logic;
    end record;
    signal decoded_reg_strb : decoded_reg_strb_t;
    signal decoded_req : std_logic;
    signal decoded_req_is_wr : std_logic;
    signal decoded_wr_data : std_logic_vector(31 downto 0);
    signal decoded_wr_biten : std_logic_vector(31 downto 0);

    ----------------------------------------------------------------------------
    -- Field Logic Signals
    ----------------------------------------------------------------------------
    -- Field Combinational Signals
    type \CsrRegisters.mstatus.sie_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.mie_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.spie_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.mpie_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.spp_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.mpp_combo_t\ is record
        next_q : std_logic_vector(1 downto 0);
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus_combo_t\ is record
        sie : \CsrRegisters.mstatus.sie_combo_t\;
        mie : \CsrRegisters.mstatus.mie_combo_t\;
        spie : \CsrRegisters.mstatus.spie_combo_t\;
        mpie : \CsrRegisters.mstatus.mpie_combo_t\;
        spp : \CsrRegisters.mstatus.spp_combo_t\;
        mpp : \CsrRegisters.mstatus.mpp_combo_t\;
    end record;

    type \CsrRegisters.mstatush.gva_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatush.mpv_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatush.mpelp_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatush.mdt_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatush_combo_t\ is record
        gva : \CsrRegisters.mstatush.gva_combo_t\;
        mpv : \CsrRegisters.mstatush.mpv_combo_t\;
        mpelp : \CsrRegisters.mstatush.mpelp_combo_t\;
        mdt : \CsrRegisters.mstatush.mdt_combo_t\;
    end record;

    type field_combo_t is record
        mstatus : \CsrRegisters.mstatus_combo_t\;
        mstatush : \CsrRegisters.mstatush_combo_t\;
    end record;
    signal field_combo : field_combo_t;

    -- Field Storage Signals
    type \CsrRegisters.mstatus.sie_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.mie_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.spie_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.mpie_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.spp_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.mpp_storage_t\ is record
        value : std_logic_vector(1 downto 0);
    end record;

    type \CsrRegisters.mstatus_storage_t\ is record
        sie : \CsrRegisters.mstatus.sie_storage_t\;
        mie : \CsrRegisters.mstatus.mie_storage_t\;
        spie : \CsrRegisters.mstatus.spie_storage_t\;
        mpie : \CsrRegisters.mstatus.mpie_storage_t\;
        spp : \CsrRegisters.mstatus.spp_storage_t\;
        mpp : \CsrRegisters.mstatus.mpp_storage_t\;
    end record;

    type \CsrRegisters.mstatush.gva_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatush.mpv_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatush.mpelp_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatush.mdt_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatush_storage_t\ is record
        gva : \CsrRegisters.mstatush.gva_storage_t\;
        mpv : \CsrRegisters.mstatush.mpv_storage_t\;
        mpelp : \CsrRegisters.mstatush.mpelp_storage_t\;
        mdt : \CsrRegisters.mstatush.mdt_storage_t\;
    end record;

    type field_storage_t is record
        mstatus : \CsrRegisters.mstatus_storage_t\;
        mstatush : \CsrRegisters.mstatush_storage_t\;
    end record;
    signal field_storage : field_storage_t;

    ----------------------------------------------------------------------------
    -- Readback Signals
    ----------------------------------------------------------------------------
    signal readback_err : std_logic;
    signal readback_done : std_logic;
    signal readback_data : std_logic_vector(31 downto 0);
    signal readback_array : std_logic_vector_array1(0 to 13)(31 downto 0);

begin

    ----------------------------------------------------------------------------
    -- CPU Bus interface
    ----------------------------------------------------------------------------
    cpuif_req <= s_cpuif_req;
    cpuif_req_is_wr <= s_cpuif_req_is_wr;
    cpuif_addr <= s_cpuif_addr;
    cpuif_wr_data <= s_cpuif_wr_data;
    cpuif_wr_biten <= s_cpuif_wr_biten;
    s_cpuif_req_stall_wr <= cpuif_req_stall_wr;
    s_cpuif_req_stall_rd <= cpuif_req_stall_rd;
    s_cpuif_rd_ack <= cpuif_rd_ack;
    s_cpuif_rd_err <= cpuif_rd_err;
    s_cpuif_rd_data <= cpuif_rd_data;
    s_cpuif_wr_ack <= cpuif_wr_ack;
    s_cpuif_wr_err <= cpuif_wr_err;

    -- Read & write latencies are balanced. Stalls not required
    cpuif_req_stall_rd <= '0';
    cpuif_req_stall_wr <= '0';
    cpuif_req_masked <= cpuif_req
                        and not (not cpuif_req_is_wr and cpuif_req_stall_rd)
                        and not (cpuif_req_is_wr and cpuif_req_stall_wr);

    ----------------------------------------------------------------------------
    -- Address Decode
    ----------------------------------------------------------------------------
    process(all)
        -- overload "=" in this scope to avoid lots of type casts
        function "="(L: std_logic_vector; R: integer) return std_logic is
            variable result : std_logic;
        begin
            result := '1' when unsigned(L) = R else '0';
            return result;
        end;
    begin
        decoded_reg_strb.mstatus <= cpuif_req_masked and (cpuif_addr = 16#C00#);
        decoded_reg_strb.misa <= cpuif_req_masked and (cpuif_addr = 16#C04#);
        decoded_reg_strb.medeleg <= cpuif_req_masked and (cpuif_addr = 16#C08#);
        decoded_reg_strb.mideleg <= cpuif_req_masked and (cpuif_addr = 16#C0C#);
        decoded_reg_strb.mie <= cpuif_req_masked and (cpuif_addr = 16#C10#);
        decoded_reg_strb.mtvec <= cpuif_req_masked and (cpuif_addr = 16#C14#);
        decoded_reg_strb.mcounteren <= cpuif_req_masked and (cpuif_addr = 16#C18#);
        decoded_reg_strb.mstatush <= cpuif_req_masked and (cpuif_addr = 16#C40#);
        decoded_reg_strb.medelegh <= cpuif_req_masked and (cpuif_addr = 16#C48#);
        decoded_reg_strb.mvendorid <= cpuif_req_masked and (cpuif_addr = 16#3C44#);
        decoded_reg_strb.marchid <= cpuif_req_masked and (cpuif_addr = 16#3C48#);
        decoded_reg_strb.mimpid <= cpuif_req_masked and (cpuif_addr = 16#3C4C#);
        decoded_reg_strb.mhartid <= cpuif_req_masked and (cpuif_addr = 16#3C50#);
        decoded_reg_strb.mconfigptr <= cpuif_req_masked and (cpuif_addr = 16#3C54#);
    end process;

    -- Pass down signals to next stage
    process(all) begin
        decoded_req <= cpuif_req_masked;
        decoded_req_is_wr <= cpuif_req_is_wr;
        decoded_wr_data <= cpuif_wr_data;
        decoded_wr_biten <= cpuif_wr_biten;
    end process;

    ----------------------------------------------------------------------------
    -- Field logic
    ----------------------------------------------------------------------------
    
    -- Field: CsrRegisters.mstatus.sie
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.sie.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.sie.value and not decoded_wr_biten(1)) or (decoded_wr_data(1) and decoded_wr_biten(1));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.sie.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.sie.next_q <= next_c;
        field_combo.mstatus.sie.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.sie.load_next then
                field_storage.mstatus.sie.value <= field_combo.mstatus.sie.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.sie.value <= field_storage.mstatus.sie.value;

    -- Field: CsrRegisters.mstatus.mie
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.mie.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.mie.value and not decoded_wr_biten(3)) or (decoded_wr_data(3) and decoded_wr_biten(3));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.mie.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.mie.next_q <= next_c;
        field_combo.mstatus.mie.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.mie.load_next then
                field_storage.mstatus.mie.value <= field_combo.mstatus.mie.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.mie.value <= field_storage.mstatus.mie.value;

    -- Field: CsrRegisters.mstatus.spie
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.spie.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.spie.value and not decoded_wr_biten(5)) or (decoded_wr_data(5) and decoded_wr_biten(5));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.spie.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.spie.next_q <= next_c;
        field_combo.mstatus.spie.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.spie.load_next then
                field_storage.mstatus.spie.value <= field_combo.mstatus.spie.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.spie.value <= field_storage.mstatus.spie.value;
    hwif_out.mstatus.ube.value <= '0';

    -- Field: CsrRegisters.mstatus.mpie
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.mpie.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.mpie.value and not decoded_wr_biten(7)) or (decoded_wr_data(7) and decoded_wr_biten(7));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.mpie.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.mpie.next_q <= next_c;
        field_combo.mstatus.mpie.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.mpie.load_next then
                field_storage.mstatus.mpie.value <= field_combo.mstatus.mpie.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.mpie.value <= field_storage.mstatus.mpie.value;

    -- Field: CsrRegisters.mstatus.spp
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.spp.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.spp.value and not decoded_wr_biten(8)) or (decoded_wr_data(8) and decoded_wr_biten(8));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.spp.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.spp.next_q <= next_c;
        field_combo.mstatus.spp.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.spp.load_next then
                field_storage.mstatus.spp.value <= field_combo.mstatus.spp.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.spp.value <= field_storage.mstatus.spp.value;
    hwif_out.mstatus.vs.value <= 2x"0";

    -- Field: CsrRegisters.mstatus.mpp
    process(all)
        variable next_c: std_logic_vector(1 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.mpp.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.mpp.value and not decoded_wr_biten(12 downto 11)) or (decoded_wr_data(12 downto 11) and decoded_wr_biten(12 downto 11));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.mpp.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.mpp.next_q <= next_c;
        field_combo.mstatus.mpp.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.mpp.load_next then
                field_storage.mstatus.mpp.value <= field_combo.mstatus.mpp.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.mpp.value <= field_storage.mstatus.mpp.value;
    hwif_out.mstatus.fs.value <= 2x"0";
    hwif_out.mstatus.xs.value <= 2x"0";
    hwif_out.mstatus.mprv.value <= '0';
    hwif_out.mstatus.sum.value <= '0';
    hwif_out.mstatus.mxr.value <= '0';
    hwif_out.mstatus.tvm.value <= '0';
    hwif_out.mstatus.tw.value <= '0';
    hwif_out.mstatus.tsr.value <= '0';
    hwif_out.mstatus.sd.value <= '0';
    hwif_out.misa.a.value <= '0';
    hwif_out.misa.b.value <= '0';
    hwif_out.misa.c.value <= '0';
    hwif_out.misa.d.value <= '0';
    hwif_out.misa.e.value <= '0';
    hwif_out.misa.f.value <= '0';
    hwif_out.misa.h.value <= '0';
    hwif_out.misa.i.value <= '1';
    hwif_out.misa.m.value <= '0';
    hwif_out.misa.n.value <= '0';
    hwif_out.misa.p.value <= '0';
    hwif_out.misa.q.value <= '0';
    hwif_out.misa.s.value <= '0';
    hwif_out.misa.u.value <= '0';
    hwif_out.misa.v.value <= '0';
    hwif_out.misa.x.value <= '0';
    hwif_out.misa.mxl.value <= 2x"1";
    hwif_out.medeleg.medeleg.value <= 'X;
    hwif_out.mideleg.mideleg.value <= 'X;
    hwif_out.mie.mie.value <= 'X;
    hwif_out.mtvec.mtvec.value <= 'X;
    hwif_out.mcounteren.mcounteren.value <= 'X;
    hwif_out.mstatush.sbe.value <= '0';
    hwif_out.mstatush.mbe.value <= '0';

    -- Field: CsrRegisters.mstatush.gva
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatush.gva.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatush and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatush.gva.value and not decoded_wr_biten(6)) or (decoded_wr_data(6) and decoded_wr_biten(6));
            load_next_c := '1';
        end if;
        field_combo.mstatush.gva.next_q <= next_c;
        field_combo.mstatush.gva.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatush.gva.load_next then
                field_storage.mstatush.gva.value <= field_combo.mstatush.gva.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatush.gva.value <= field_storage.mstatush.gva.value;

    -- Field: CsrRegisters.mstatush.mpv
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatush.mpv.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatush and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatush.mpv.value and not decoded_wr_biten(7)) or (decoded_wr_data(7) and decoded_wr_biten(7));
            load_next_c := '1';
        end if;
        field_combo.mstatush.mpv.next_q <= next_c;
        field_combo.mstatush.mpv.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatush.mpv.load_next then
                field_storage.mstatush.mpv.value <= field_combo.mstatush.mpv.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatush.mpv.value <= field_storage.mstatush.mpv.value;

    -- Field: CsrRegisters.mstatush.mpelp
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatush.mpelp.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatush and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatush.mpelp.value and not decoded_wr_biten(9)) or (decoded_wr_data(9) and decoded_wr_biten(9));
            load_next_c := '1';
        end if;
        field_combo.mstatush.mpelp.next_q <= next_c;
        field_combo.mstatush.mpelp.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatush.mpelp.load_next then
                field_storage.mstatush.mpelp.value <= field_combo.mstatush.mpelp.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatush.mpelp.value <= field_storage.mstatush.mpelp.value;

    -- Field: CsrRegisters.mstatush.mdt
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatush.mdt.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatush and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatush.mdt.value and not decoded_wr_biten(10)) or (decoded_wr_data(10) and decoded_wr_biten(10));
            load_next_c := '1';
        end if;
        field_combo.mstatush.mdt.next_q <= next_c;
        field_combo.mstatush.mdt.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatush.mdt.load_next then
                field_storage.mstatush.mdt.value <= field_combo.mstatush.mdt.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatush.mdt.value <= field_storage.mstatush.mdt.value;
    hwif_out.medelegh.medelegh.value <= 'X;
    hwif_out.mvendorid.offset.value <= 7x"0";
    hwif_out.mvendorid.bank.value <= 25x"0";
    hwif_out.marchid.marchid.value <= 32x"0";
    hwif_out.mimpid.mimpid.value <= 32x"0";
    hwif_out.mhartid.mhartid.value <= 32x"0";
    hwif_out.mconfigptr.mconfigptr.value <= 32x"0";

    ----------------------------------------------------------------------------
    -- Write response
    ----------------------------------------------------------------------------
    cpuif_wr_ack <= decoded_req and decoded_req_is_wr;
    -- Writes are always granted with no error response
    cpuif_wr_err <= '0';

    ----------------------------------------------------------------------------
    -- Readback
    ----------------------------------------------------------------------------

    -- Assign readback values to a flattened array
    readback_array(0)(0 downto 0) <= (others => '0');
    readback_array(0)(1 downto 1) <= to_std_logic_vector(field_storage.mstatus.sie.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(2 downto 2) <= (others => '0');
    readback_array(0)(3 downto 3) <= to_std_logic_vector(field_storage.mstatus.mie.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(4 downto 4) <= (others => '0');
    readback_array(0)(5 downto 5) <= to_std_logic_vector(field_storage.mstatus.spie.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(6 downto 6) <= '0' when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(7 downto 7) <= to_std_logic_vector(field_storage.mstatus.mpie.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(8 downto 8) <= to_std_logic_vector(field_storage.mstatus.spp.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(10 downto 9) <= 2x"0" when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(12 downto 11) <= field_storage.mstatus.mpp.value when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(14 downto 13) <= 2x"0" when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(16 downto 15) <= 2x"0" when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(17 downto 17) <= '0' when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(18 downto 18) <= '0' when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(19 downto 19) <= '0' when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(20 downto 20) <= '0' when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(21 downto 21) <= '0' when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(22 downto 22) <= '0' when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(30 downto 23) <= (others => '0');
    readback_array(0)(31 downto 31) <= '0' when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(0 downto 0) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(1 downto 1) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(2 downto 2) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(3 downto 3) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(4 downto 4) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(5 downto 5) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(6 downto 6) <= (others => '0');
    readback_array(1)(7 downto 7) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(8 downto 8) <= '1' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(11 downto 9) <= (others => '0');
    readback_array(1)(12 downto 12) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(13 downto 13) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(14 downto 14) <= (others => '0');
    readback_array(1)(15 downto 15) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(16 downto 16) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(17 downto 17) <= (others => '0');
    readback_array(1)(18 downto 18) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(19 downto 19) <= (others => '0');
    readback_array(1)(20 downto 20) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(21 downto 21) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(22 downto 22) <= (others => '0');
    readback_array(1)(23 downto 23) <= '0' when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(29 downto 24) <= (others => '0');
    readback_array(1)(31 downto 30) <= 2x"1" when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(2)(31 downto 0) <= 'X when (decoded_reg_strb.medeleg and not decoded_req_is_wr) else (others => '0');
    readback_array(3)(31 downto 0) <= 'X when (decoded_reg_strb.mideleg and not decoded_req_is_wr) else (others => '0');
    readback_array(4)(31 downto 0) <= 'X when (decoded_reg_strb.mie and not decoded_req_is_wr) else (others => '0');
    readback_array(5)(31 downto 0) <= 'X when (decoded_reg_strb.mtvec and not decoded_req_is_wr) else (others => '0');
    readback_array(6)(31 downto 0) <= 'X when (decoded_reg_strb.mcounteren and not decoded_req_is_wr) else (others => '0');
    readback_array(7)(3 downto 0) <= (others => '0');
    readback_array(7)(4 downto 4) <= '0' when (decoded_reg_strb.mstatush and not decoded_req_is_wr) else (others => '0');
    readback_array(7)(5 downto 5) <= '0' when (decoded_reg_strb.mstatush and not decoded_req_is_wr) else (others => '0');
    readback_array(7)(6 downto 6) <= to_std_logic_vector(field_storage.mstatush.gva.value) when (decoded_reg_strb.mstatush and not decoded_req_is_wr) else (others => '0');
    readback_array(7)(7 downto 7) <= to_std_logic_vector(field_storage.mstatush.mpv.value) when (decoded_reg_strb.mstatush and not decoded_req_is_wr) else (others => '0');
    readback_array(7)(8 downto 8) <= (others => '0');
    readback_array(7)(9 downto 9) <= to_std_logic_vector(field_storage.mstatush.mpelp.value) when (decoded_reg_strb.mstatush and not decoded_req_is_wr) else (others => '0');
    readback_array(7)(10 downto 10) <= to_std_logic_vector(field_storage.mstatush.mdt.value) when (decoded_reg_strb.mstatush and not decoded_req_is_wr) else (others => '0');
    readback_array(7)(31 downto 11) <= (others => '0');
    readback_array(8)(31 downto 0) <= 'X when (decoded_reg_strb.medelegh and not decoded_req_is_wr) else (others => '0');
    readback_array(9)(6 downto 0) <= 7x"0" when (decoded_reg_strb.mvendorid and not decoded_req_is_wr) else (others => '0');
    readback_array(9)(31 downto 7) <= 25x"0" when (decoded_reg_strb.mvendorid and not decoded_req_is_wr) else (others => '0');
    readback_array(10)(31 downto 0) <= 32x"0" when (decoded_reg_strb.marchid and not decoded_req_is_wr) else (others => '0');
    readback_array(11)(31 downto 0) <= 32x"0" when (decoded_reg_strb.mimpid and not decoded_req_is_wr) else (others => '0');
    readback_array(12)(31 downto 0) <= 32x"0" when (decoded_reg_strb.mhartid and not decoded_req_is_wr) else (others => '0');
    readback_array(13)(31 downto 0) <= 32x"0" when (decoded_reg_strb.mconfigptr and not decoded_req_is_wr) else (others => '0');

    -- Reduce the array
    process(all)
        variable readback_data_var : std_logic_vector(31 downto 0) := (others => '0');
    begin
        readback_done <= decoded_req and not decoded_req_is_wr;
        readback_err <= '0';
        readback_data_var := (others => '0');
        for i in readback_array'RANGE loop
            readback_data_var := readback_data_var or readback_array(i);
        end loop;
        readback_data <= readback_data_var;
    end process;

    cpuif_rd_ack <= readback_done;
    cpuif_rd_data <= readback_data;
    cpuif_rd_err <= readback_err;
end architecture rtl;
