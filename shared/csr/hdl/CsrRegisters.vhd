-- Generated by PeakRDL-regblock-vhdl - A free and open-source VHDL generator
--  https://github.com/SystemRDL/PeakRDL-regblock-vhdl
library ieee;
context ieee.ieee_std_context;
use ieee.fixed_pkg.all;

use work.CsrRegisters_pkg.all;
use work.reg_utils.all;

entity CsrRegisters is
    port (
        clk : in std_logic;
        rst : in std_logic;

        s_cpuif_req : in std_logic;
        s_cpuif_req_is_wr : in std_logic;
        s_cpuif_addr : in std_logic_vector(11 downto 0);
        s_cpuif_wr_data : in std_logic_vector(31 downto 0);
        s_cpuif_wr_biten : in std_logic_vector(31 downto 0);
        s_cpuif_req_stall_wr : out std_logic;
        s_cpuif_req_stall_rd : out std_logic;
        s_cpuif_rd_ack : out std_logic;
        s_cpuif_rd_err : out std_logic;
        s_cpuif_rd_data : out std_logic_vector(31 downto 0);
        s_cpuif_wr_ack : out std_logic;
        s_cpuif_wr_err : out std_logic;

        hwif_in : in CsrRegisters_in_t;
        hwif_out : out CsrRegisters_out_t
    );
end entity CsrRegisters;

architecture rtl of CsrRegisters is
    ----------------------------------------------------------------------------
    -- CPU Bus interface signals
    ----------------------------------------------------------------------------
    signal cpuif_req : std_logic;
    signal cpuif_req_is_wr : std_logic;
    signal cpuif_addr : std_logic_vector(11 downto 0);
    signal cpuif_wr_data : std_logic_vector(31 downto 0);
    signal cpuif_wr_biten : std_logic_vector(31 downto 0);
    signal cpuif_req_stall_wr : std_logic;
    signal cpuif_req_stall_rd : std_logic;

    signal cpuif_rd_ack : std_logic;
    signal cpuif_rd_err : std_logic;
    signal cpuif_rd_data : std_logic_vector(31 downto 0);

    signal cpuif_wr_ack : std_logic;
    signal cpuif_wr_err : std_logic;

    signal cpuif_req_masked : std_logic;

    

    ----------------------------------------------------------------------------
    -- Address Decode Signals
    ----------------------------------------------------------------------------
    type decoded_reg_strb_t is record
        mstatus : std_logic;
        misa : std_logic;
        mie : std_logic;
        mtvec : std_logic;
    end record;
    signal decoded_reg_strb : decoded_reg_strb_t;
    signal decoded_req : std_logic;
    signal decoded_req_is_wr : std_logic;
    signal decoded_wr_data : std_logic_vector(31 downto 0);
    signal decoded_wr_biten : std_logic_vector(31 downto 0);

    ----------------------------------------------------------------------------
    -- Field Logic Signals
    ----------------------------------------------------------------------------
    -- Field Combinational Signals
    type \CsrRegisters.mstatus.sie_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.mie_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.spie_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.ube_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.mpie_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.spp_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.vs_combo_t\ is record
        next_q : std_logic_vector(1 downto 0);
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.mpp_combo_t\ is record
        next_q : std_logic_vector(1 downto 0);
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.fs_combo_t\ is record
        next_q : std_logic_vector(1 downto 0);
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.xs_combo_t\ is record
        next_q : std_logic_vector(1 downto 0);
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.mprv_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.sum_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.mxr_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.tvm_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.tw_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.tsr_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.spelp_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.sdt_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus.sd_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \CsrRegisters.mstatus_combo_t\ is record
        sie : \CsrRegisters.mstatus.sie_combo_t\;
        mie : \CsrRegisters.mstatus.mie_combo_t\;
        spie : \CsrRegisters.mstatus.spie_combo_t\;
        ube : \CsrRegisters.mstatus.ube_combo_t\;
        mpie : \CsrRegisters.mstatus.mpie_combo_t\;
        spp : \CsrRegisters.mstatus.spp_combo_t\;
        vs : \CsrRegisters.mstatus.vs_combo_t\;
        mpp : \CsrRegisters.mstatus.mpp_combo_t\;
        fs : \CsrRegisters.mstatus.fs_combo_t\;
        xs : \CsrRegisters.mstatus.xs_combo_t\;
        mprv : \CsrRegisters.mstatus.mprv_combo_t\;
        sum : \CsrRegisters.mstatus.sum_combo_t\;
        mxr : \CsrRegisters.mstatus.mxr_combo_t\;
        tvm : \CsrRegisters.mstatus.tvm_combo_t\;
        tw : \CsrRegisters.mstatus.tw_combo_t\;
        tsr : \CsrRegisters.mstatus.tsr_combo_t\;
        spelp : \CsrRegisters.mstatus.spelp_combo_t\;
        sdt : \CsrRegisters.mstatus.sdt_combo_t\;
        sd : \CsrRegisters.mstatus.sd_combo_t\;
    end record;

    type \CsrRegisters.misa.misa_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \CsrRegisters.misa_combo_t\ is record
        misa : \CsrRegisters.misa.misa_combo_t\;
    end record;

    type \CsrRegisters.mie.mie_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \CsrRegisters.mie_combo_t\ is record
        mie : \CsrRegisters.mie.mie_combo_t\;
    end record;

    type \CsrRegisters.mtvec.mtvec_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \CsrRegisters.mtvec_combo_t\ is record
        mtvec : \CsrRegisters.mtvec.mtvec_combo_t\;
    end record;

    type field_combo_t is record
        mstatus : \CsrRegisters.mstatus_combo_t\;
        misa : \CsrRegisters.misa_combo_t\;
        mie : \CsrRegisters.mie_combo_t\;
        mtvec : \CsrRegisters.mtvec_combo_t\;
    end record;
    signal field_combo : field_combo_t;

    -- Field Storage Signals
    type \CsrRegisters.mstatus.sie_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.mie_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.spie_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.ube_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.mpie_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.spp_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.vs_storage_t\ is record
        value : std_logic_vector(1 downto 0);
    end record;

    type \CsrRegisters.mstatus.mpp_storage_t\ is record
        value : std_logic_vector(1 downto 0);
    end record;

    type \CsrRegisters.mstatus.fs_storage_t\ is record
        value : std_logic_vector(1 downto 0);
    end record;

    type \CsrRegisters.mstatus.xs_storage_t\ is record
        value : std_logic_vector(1 downto 0);
    end record;

    type \CsrRegisters.mstatus.mprv_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.sum_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.mxr_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.tvm_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.tw_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.tsr_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.spelp_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.sdt_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus.sd_storage_t\ is record
        value : std_logic;
    end record;

    type \CsrRegisters.mstatus_storage_t\ is record
        sie : \CsrRegisters.mstatus.sie_storage_t\;
        mie : \CsrRegisters.mstatus.mie_storage_t\;
        spie : \CsrRegisters.mstatus.spie_storage_t\;
        ube : \CsrRegisters.mstatus.ube_storage_t\;
        mpie : \CsrRegisters.mstatus.mpie_storage_t\;
        spp : \CsrRegisters.mstatus.spp_storage_t\;
        vs : \CsrRegisters.mstatus.vs_storage_t\;
        mpp : \CsrRegisters.mstatus.mpp_storage_t\;
        fs : \CsrRegisters.mstatus.fs_storage_t\;
        xs : \CsrRegisters.mstatus.xs_storage_t\;
        mprv : \CsrRegisters.mstatus.mprv_storage_t\;
        sum : \CsrRegisters.mstatus.sum_storage_t\;
        mxr : \CsrRegisters.mstatus.mxr_storage_t\;
        tvm : \CsrRegisters.mstatus.tvm_storage_t\;
        tw : \CsrRegisters.mstatus.tw_storage_t\;
        tsr : \CsrRegisters.mstatus.tsr_storage_t\;
        spelp : \CsrRegisters.mstatus.spelp_storage_t\;
        sdt : \CsrRegisters.mstatus.sdt_storage_t\;
        sd : \CsrRegisters.mstatus.sd_storage_t\;
    end record;

    type \CsrRegisters.misa.misa_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \CsrRegisters.misa_storage_t\ is record
        misa : \CsrRegisters.misa.misa_storage_t\;
    end record;

    type \CsrRegisters.mie.mie_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \CsrRegisters.mie_storage_t\ is record
        mie : \CsrRegisters.mie.mie_storage_t\;
    end record;

    type \CsrRegisters.mtvec.mtvec_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \CsrRegisters.mtvec_storage_t\ is record
        mtvec : \CsrRegisters.mtvec.mtvec_storage_t\;
    end record;

    type field_storage_t is record
        mstatus : \CsrRegisters.mstatus_storage_t\;
        misa : \CsrRegisters.misa_storage_t\;
        mie : \CsrRegisters.mie_storage_t\;
        mtvec : \CsrRegisters.mtvec_storage_t\;
    end record;
    signal field_storage : field_storage_t;

    ----------------------------------------------------------------------------
    -- Readback Signals
    ----------------------------------------------------------------------------
    signal readback_err : std_logic;
    signal readback_done : std_logic;
    signal readback_data : std_logic_vector(31 downto 0);
    signal readback_array : std_logic_vector_array1(0 to 3)(31 downto 0);

begin

    ----------------------------------------------------------------------------
    -- CPU Bus interface
    ----------------------------------------------------------------------------
    cpuif_req <= s_cpuif_req;
    cpuif_req_is_wr <= s_cpuif_req_is_wr;
    cpuif_addr <= s_cpuif_addr;
    cpuif_wr_data <= s_cpuif_wr_data;
    cpuif_wr_biten <= s_cpuif_wr_biten;
    s_cpuif_req_stall_wr <= cpuif_req_stall_wr;
    s_cpuif_req_stall_rd <= cpuif_req_stall_rd;
    s_cpuif_rd_ack <= cpuif_rd_ack;
    s_cpuif_rd_err <= cpuif_rd_err;
    s_cpuif_rd_data <= cpuif_rd_data;
    s_cpuif_wr_ack <= cpuif_wr_ack;
    s_cpuif_wr_err <= cpuif_wr_err;

    -- Read & write latencies are balanced. Stalls not required
    cpuif_req_stall_rd <= '0';
    cpuif_req_stall_wr <= '0';
    cpuif_req_masked <= cpuif_req
                        and not (not cpuif_req_is_wr and cpuif_req_stall_rd)
                        and not (cpuif_req_is_wr and cpuif_req_stall_wr);

    ----------------------------------------------------------------------------
    -- Address Decode
    ----------------------------------------------------------------------------
    process(all)
        -- overload "=" in this scope to avoid lots of type casts
        function "="(L: std_logic_vector; R: integer) return std_logic is
            variable result : std_logic;
        begin
            result := '1' when unsigned(L) = R else '0';
            return result;
        end;
    begin
        decoded_reg_strb.mstatus <= cpuif_req_masked and (cpuif_addr = 16#C00#);
        decoded_reg_strb.misa <= cpuif_req_masked and (cpuif_addr = 16#C04#);
        decoded_reg_strb.mie <= cpuif_req_masked and (cpuif_addr = 16#C10#);
        decoded_reg_strb.mtvec <= cpuif_req_masked and (cpuif_addr = 16#C14#);
    end process;

    -- Pass down signals to next stage
    process(all) begin
        decoded_req <= cpuif_req_masked;
        decoded_req_is_wr <= cpuif_req_is_wr;
        decoded_wr_data <= cpuif_wr_data;
        decoded_wr_biten <= cpuif_wr_biten;
    end process;

    ----------------------------------------------------------------------------
    -- Field logic
    ----------------------------------------------------------------------------
    
    -- Field: CsrRegisters.mstatus.sie
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.sie.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.sie.value and not decoded_wr_biten(1)) or (decoded_wr_data(1) and decoded_wr_biten(1));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.sie.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.sie.next_q <= next_c;
        field_combo.mstatus.sie.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.sie.load_next then
                field_storage.mstatus.sie.value <= field_combo.mstatus.sie.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.sie.value <= field_storage.mstatus.sie.value;

    -- Field: CsrRegisters.mstatus.mie
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.mie.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.mie.value and not decoded_wr_biten(3)) or (decoded_wr_data(3) and decoded_wr_biten(3));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.mie.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.mie.next_q <= next_c;
        field_combo.mstatus.mie.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.mie.load_next then
                field_storage.mstatus.mie.value <= field_combo.mstatus.mie.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.mie.value <= field_storage.mstatus.mie.value;

    -- Field: CsrRegisters.mstatus.spie
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.spie.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.spie.value and not decoded_wr_biten(5)) or (decoded_wr_data(5) and decoded_wr_biten(5));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.spie.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.spie.next_q <= next_c;
        field_combo.mstatus.spie.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.spie.load_next then
                field_storage.mstatus.spie.value <= field_combo.mstatus.spie.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.spie.value <= field_storage.mstatus.spie.value;

    -- Field: CsrRegisters.mstatus.ube
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.ube.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.ube.value and not decoded_wr_biten(6)) or (decoded_wr_data(6) and decoded_wr_biten(6));
            load_next_c := '1';
        end if;
        field_combo.mstatus.ube.next_q <= next_c;
        field_combo.mstatus.ube.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.ube.load_next then
                field_storage.mstatus.ube.value <= field_combo.mstatus.ube.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.ube.value <= field_storage.mstatus.ube.value;

    -- Field: CsrRegisters.mstatus.mpie
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.mpie.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.mpie.value and not decoded_wr_biten(7)) or (decoded_wr_data(7) and decoded_wr_biten(7));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.mpie.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.mpie.next_q <= next_c;
        field_combo.mstatus.mpie.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.mpie.load_next then
                field_storage.mstatus.mpie.value <= field_combo.mstatus.mpie.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.mpie.value <= field_storage.mstatus.mpie.value;

    -- Field: CsrRegisters.mstatus.spp
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.spp.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.spp.value and not decoded_wr_biten(8)) or (decoded_wr_data(8) and decoded_wr_biten(8));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.spp.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.spp.next_q <= next_c;
        field_combo.mstatus.spp.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.spp.load_next then
                field_storage.mstatus.spp.value <= field_combo.mstatus.spp.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.spp.value <= field_storage.mstatus.spp.value;

    -- Field: CsrRegisters.mstatus.vs
    process(all)
        variable next_c: std_logic_vector(1 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.vs.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.vs.value and not decoded_wr_biten(10 downto 9)) or (decoded_wr_data(10 downto 9) and decoded_wr_biten(10 downto 9));
            load_next_c := '1';
        end if;
        field_combo.mstatus.vs.next_q <= next_c;
        field_combo.mstatus.vs.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.vs.load_next then
                field_storage.mstatus.vs.value <= field_combo.mstatus.vs.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.vs.value <= field_storage.mstatus.vs.value;

    -- Field: CsrRegisters.mstatus.mpp
    process(all)
        variable next_c: std_logic_vector(1 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.mpp.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.mpp.value and not decoded_wr_biten(12 downto 11)) or (decoded_wr_data(12 downto 11) and decoded_wr_biten(12 downto 11));
            load_next_c := '1';
        else -- HW Write
            next_c := hwif_in.mstatus.mpp.next_q;
            load_next_c := '1';
        end if;
        field_combo.mstatus.mpp.next_q <= next_c;
        field_combo.mstatus.mpp.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.mpp.load_next then
                field_storage.mstatus.mpp.value <= field_combo.mstatus.mpp.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.mpp.value <= field_storage.mstatus.mpp.value;

    -- Field: CsrRegisters.mstatus.fs
    process(all)
        variable next_c: std_logic_vector(1 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.fs.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.fs.value and not decoded_wr_biten(14 downto 13)) or (decoded_wr_data(14 downto 13) and decoded_wr_biten(14 downto 13));
            load_next_c := '1';
        end if;
        field_combo.mstatus.fs.next_q <= next_c;
        field_combo.mstatus.fs.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.fs.load_next then
                field_storage.mstatus.fs.value <= field_combo.mstatus.fs.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.fs.value <= field_storage.mstatus.fs.value;

    -- Field: CsrRegisters.mstatus.xs
    process(all)
        variable next_c: std_logic_vector(1 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.xs.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.xs.value and not decoded_wr_biten(16 downto 15)) or (decoded_wr_data(16 downto 15) and decoded_wr_biten(16 downto 15));
            load_next_c := '1';
        end if;
        field_combo.mstatus.xs.next_q <= next_c;
        field_combo.mstatus.xs.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.xs.load_next then
                field_storage.mstatus.xs.value <= field_combo.mstatus.xs.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.xs.value <= field_storage.mstatus.xs.value;

    -- Field: CsrRegisters.mstatus.mprv
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.mprv.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.mprv.value and not decoded_wr_biten(17)) or (decoded_wr_data(17) and decoded_wr_biten(17));
            load_next_c := '1';
        end if;
        field_combo.mstatus.mprv.next_q <= next_c;
        field_combo.mstatus.mprv.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.mprv.load_next then
                field_storage.mstatus.mprv.value <= field_combo.mstatus.mprv.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.mprv.value <= field_storage.mstatus.mprv.value;

    -- Field: CsrRegisters.mstatus.sum
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.sum.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.sum.value and not decoded_wr_biten(18)) or (decoded_wr_data(18) and decoded_wr_biten(18));
            load_next_c := '1';
        end if;
        field_combo.mstatus.sum.next_q <= next_c;
        field_combo.mstatus.sum.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.sum.load_next then
                field_storage.mstatus.sum.value <= field_combo.mstatus.sum.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.sum.value <= field_storage.mstatus.sum.value;

    -- Field: CsrRegisters.mstatus.mxr
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.mxr.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.mxr.value and not decoded_wr_biten(19)) or (decoded_wr_data(19) and decoded_wr_biten(19));
            load_next_c := '1';
        end if;
        field_combo.mstatus.mxr.next_q <= next_c;
        field_combo.mstatus.mxr.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.mxr.load_next then
                field_storage.mstatus.mxr.value <= field_combo.mstatus.mxr.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.mxr.value <= field_storage.mstatus.mxr.value;

    -- Field: CsrRegisters.mstatus.tvm
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.tvm.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.tvm.value and not decoded_wr_biten(20)) or (decoded_wr_data(20) and decoded_wr_biten(20));
            load_next_c := '1';
        end if;
        field_combo.mstatus.tvm.next_q <= next_c;
        field_combo.mstatus.tvm.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.tvm.load_next then
                field_storage.mstatus.tvm.value <= field_combo.mstatus.tvm.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.tvm.value <= field_storage.mstatus.tvm.value;

    -- Field: CsrRegisters.mstatus.tw
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.tw.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.tw.value and not decoded_wr_biten(21)) or (decoded_wr_data(21) and decoded_wr_biten(21));
            load_next_c := '1';
        end if;
        field_combo.mstatus.tw.next_q <= next_c;
        field_combo.mstatus.tw.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.tw.load_next then
                field_storage.mstatus.tw.value <= field_combo.mstatus.tw.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.tw.value <= field_storage.mstatus.tw.value;

    -- Field: CsrRegisters.mstatus.tsr
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.tsr.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.tsr.value and not decoded_wr_biten(22)) or (decoded_wr_data(22) and decoded_wr_biten(22));
            load_next_c := '1';
        end if;
        field_combo.mstatus.tsr.next_q <= next_c;
        field_combo.mstatus.tsr.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.tsr.load_next then
                field_storage.mstatus.tsr.value <= field_combo.mstatus.tsr.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.tsr.value <= field_storage.mstatus.tsr.value;

    -- Field: CsrRegisters.mstatus.spelp
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.spelp.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.spelp.value and not decoded_wr_biten(23)) or (decoded_wr_data(23) and decoded_wr_biten(23));
            load_next_c := '1';
        end if;
        field_combo.mstatus.spelp.next_q <= next_c;
        field_combo.mstatus.spelp.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.spelp.load_next then
                field_storage.mstatus.spelp.value <= field_combo.mstatus.spelp.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.spelp.value <= field_storage.mstatus.spelp.value;

    -- Field: CsrRegisters.mstatus.sdt
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.sdt.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.sdt.value and not decoded_wr_biten(24)) or (decoded_wr_data(24) and decoded_wr_biten(24));
            load_next_c := '1';
        end if;
        field_combo.mstatus.sdt.next_q <= next_c;
        field_combo.mstatus.sdt.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.sdt.load_next then
                field_storage.mstatus.sdt.value <= field_combo.mstatus.sdt.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.sdt.value <= field_storage.mstatus.sdt.value;

    -- Field: CsrRegisters.mstatus.sd
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mstatus.sd.value;
        load_next_c := '0';
        if decoded_reg_strb.mstatus and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mstatus.sd.value and not decoded_wr_biten(31)) or (decoded_wr_data(31) and decoded_wr_biten(31));
            load_next_c := '1';
        end if;
        field_combo.mstatus.sd.next_q <= next_c;
        field_combo.mstatus.sd.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mstatus.sd.load_next then
                field_storage.mstatus.sd.value <= field_combo.mstatus.sd.next_q;
            end if;
        end if;
    end process;
    hwif_out.mstatus.sd.value <= field_storage.mstatus.sd.value;

    -- Field: CsrRegisters.misa.misa
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.misa.misa.value;
        load_next_c := '0';
        if decoded_reg_strb.misa and decoded_req_is_wr then -- SW write
            next_c := (field_storage.misa.misa.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.misa.misa.next_q <= next_c;
        field_combo.misa.misa.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.misa.misa.load_next then
                field_storage.misa.misa.value <= field_combo.misa.misa.next_q;
            end if;
        end if;
    end process;
    hwif_out.misa.misa.value <= field_storage.misa.misa.value;

    -- Field: CsrRegisters.mie.mie
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mie.mie.value;
        load_next_c := '0';
        if decoded_reg_strb.mie and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mie.mie.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.mie.mie.next_q <= next_c;
        field_combo.mie.mie.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mie.mie.load_next then
                field_storage.mie.mie.value <= field_combo.mie.mie.next_q;
            end if;
        end if;
    end process;
    hwif_out.mie.mie.value <= field_storage.mie.mie.value;

    -- Field: CsrRegisters.mtvec.mtvec
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.mtvec.mtvec.value;
        load_next_c := '0';
        if decoded_reg_strb.mtvec and decoded_req_is_wr then -- SW write
            next_c := (field_storage.mtvec.mtvec.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.mtvec.mtvec.next_q <= next_c;
        field_combo.mtvec.mtvec.load_next <= load_next_c;
    end process;
    process(clk) begin
        if rising_edge(clk) then
            if field_combo.mtvec.mtvec.load_next then
                field_storage.mtvec.mtvec.value <= field_combo.mtvec.mtvec.next_q;
            end if;
        end if;
    end process;
    hwif_out.mtvec.mtvec.value <= field_storage.mtvec.mtvec.value;

    ----------------------------------------------------------------------------
    -- Write response
    ----------------------------------------------------------------------------
    cpuif_wr_ack <= decoded_req and decoded_req_is_wr;
    -- Writes are always granted with no error response
    cpuif_wr_err <= '0';

    ----------------------------------------------------------------------------
    -- Readback
    ----------------------------------------------------------------------------

    -- Assign readback values to a flattened array
    readback_array(0)(0 downto 0) <= (others => '0');
    readback_array(0)(1 downto 1) <= to_std_logic_vector(field_storage.mstatus.sie.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(2 downto 2) <= (others => '0');
    readback_array(0)(3 downto 3) <= to_std_logic_vector(field_storage.mstatus.mie.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(4 downto 4) <= (others => '0');
    readback_array(0)(5 downto 5) <= to_std_logic_vector(field_storage.mstatus.spie.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(6 downto 6) <= to_std_logic_vector(field_storage.mstatus.ube.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(7 downto 7) <= to_std_logic_vector(field_storage.mstatus.mpie.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(8 downto 8) <= to_std_logic_vector(field_storage.mstatus.spp.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(10 downto 9) <= field_storage.mstatus.vs.value when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(12 downto 11) <= field_storage.mstatus.mpp.value when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(14 downto 13) <= field_storage.mstatus.fs.value when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(16 downto 15) <= field_storage.mstatus.xs.value when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(17 downto 17) <= to_std_logic_vector(field_storage.mstatus.mprv.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(18 downto 18) <= to_std_logic_vector(field_storage.mstatus.sum.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(19 downto 19) <= to_std_logic_vector(field_storage.mstatus.mxr.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(20 downto 20) <= to_std_logic_vector(field_storage.mstatus.tvm.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(21 downto 21) <= to_std_logic_vector(field_storage.mstatus.tw.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(22 downto 22) <= to_std_logic_vector(field_storage.mstatus.tsr.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(23 downto 23) <= to_std_logic_vector(field_storage.mstatus.spelp.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(24 downto 24) <= to_std_logic_vector(field_storage.mstatus.sdt.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(0)(30 downto 25) <= (others => '0');
    readback_array(0)(31 downto 31) <= to_std_logic_vector(field_storage.mstatus.sd.value) when (decoded_reg_strb.mstatus and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(31 downto 0) <= field_storage.misa.misa.value when (decoded_reg_strb.misa and not decoded_req_is_wr) else (others => '0');
    readback_array(2)(31 downto 0) <= field_storage.mie.mie.value when (decoded_reg_strb.mie and not decoded_req_is_wr) else (others => '0');
    readback_array(3)(31 downto 0) <= field_storage.mtvec.mtvec.value when (decoded_reg_strb.mtvec and not decoded_req_is_wr) else (others => '0');

    -- Reduce the array
    process(all)
        variable readback_data_var : std_logic_vector(31 downto 0) := (others => '0');
    begin
        readback_done <= decoded_req and not decoded_req_is_wr;
        readback_err <= '0';
        readback_data_var := (others => '0');
        for i in readback_array'RANGE loop
            readback_data_var := readback_data_var or readback_array(i);
        end loop;
        readback_data <= readback_data_var;
    end process;

    cpuif_rd_ack <= readback_done;
    cpuif_rd_data <= readback_data;
    cpuif_rd_err <= readback_err;
end architecture rtl;
