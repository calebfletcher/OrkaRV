-- Generated by PeakRDL-regblock-vhdl - A free and open-source VHDL generator
--  https://github.com/SystemRDL/PeakRDL-regblock-vhdl
library ieee;
context ieee.ieee_std_context;
use ieee.fixed_pkg.all;

use work.GpioRegisters_pkg.all;
use work.axi4lite_intf_pkg.all;
use work.reg_utils.all;

entity GpioRegisters is
    port (
        clk : in std_logic;
        rst : in std_logic;

        s_axil_i : in axi4lite_slave_in_intf(
            AWADDR(3 downto 0),
            WDATA(31 downto 0),
            WSTRB(3 downto 0),
            ARADDR(3 downto 0)
        );
        s_axil_o : out axi4lite_slave_out_intf(
            RDATA(31 downto 0)
        );

        hwif_in : in GpioRegisters_in_t;
        hwif_out : out GpioRegisters_out_t
    );
end entity GpioRegisters;

architecture rtl of GpioRegisters is
    ----------------------------------------------------------------------------
    -- CPU Bus interface signals
    ----------------------------------------------------------------------------
    signal cpuif_req : std_logic;
    signal cpuif_req_is_wr : std_logic;
    signal cpuif_addr : std_logic_vector(3 downto 0);
    signal cpuif_wr_data : std_logic_vector(31 downto 0);
    signal cpuif_wr_biten : std_logic_vector(31 downto 0);
    signal cpuif_req_stall_wr : std_logic;
    signal cpuif_req_stall_rd : std_logic;

    signal cpuif_rd_ack : std_logic;
    signal cpuif_rd_err : std_logic;
    signal cpuif_rd_data : std_logic_vector(31 downto 0);

    signal cpuif_wr_ack : std_logic;
    signal cpuif_wr_err : std_logic;

    signal cpuif_req_masked : std_logic;

    signal axil_n_in_flight : unsigned(1 downto 0);
    signal axil_prev_was_rd : std_logic;
    signal axil_arvalid : std_logic;
    signal axil_araddr : std_logic_vector(3 downto 0);
    signal axil_ar_accept : std_logic;
    signal axil_awvalid : std_logic;
    signal axil_awaddr : std_logic_vector(3 downto 0);
    signal axil_wvalid : std_logic;
    signal axil_wdata : std_logic_vector(31 downto 0);
    signal axil_wstrb : std_logic_vector(3 downto 0);
    signal axil_aw_accept : std_logic;
    signal axil_resp_acked : std_logic;
    type axil_resp_buffer_t is record
        is_wr : std_logic;
        err : std_logic;
        rdata : std_logic_vector(31 downto 0);
    end record axil_resp_buffer_t;
    type axil_resp_buffer_array_t is array (integer range <>) of axil_resp_buffer_t;
    signal axil_resp_buffer : axil_resp_buffer_array_t(1 downto 0);
    signal axil_resp_wptr : unsigned(1 downto 0);
    signal axil_resp_rptr : unsigned(1 downto 0);

    ----------------------------------------------------------------------------
    -- Address Decode Signals
    ----------------------------------------------------------------------------
    type decoded_reg_strb_t is record
        direction : std_logic;
        output : std_logic;
        input : std_logic;
    end record;
    signal decoded_reg_strb : decoded_reg_strb_t;
    signal decoded_err : std_logic;
    signal decoded_req : std_logic;
    signal decoded_req_is_wr : std_logic;
    signal decoded_wr_data : std_logic_vector(31 downto 0);
    signal decoded_wr_biten : std_logic_vector(31 downto 0);

    ----------------------------------------------------------------------------
    -- Field Logic Signals
    ----------------------------------------------------------------------------
    -- Field Combinational Signals
    type \GpioRegisters.direction.direction_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \GpioRegisters.direction_combo_t\ is record
        direction : \GpioRegisters.direction.direction_combo_t\;
    end record;

    type \GpioRegisters.output.output_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \GpioRegisters.output_combo_t\ is record
        output : \GpioRegisters.output.output_combo_t\;
    end record;

    type field_combo_t is record
        direction : \GpioRegisters.direction_combo_t\;
        output : \GpioRegisters.output_combo_t\;
    end record;
    signal field_combo : field_combo_t;

    -- Field Storage Signals
    type \GpioRegisters.direction.direction_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \GpioRegisters.direction_storage_t\ is record
        direction : \GpioRegisters.direction.direction_storage_t\;
    end record;

    type \GpioRegisters.output.output_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \GpioRegisters.output_storage_t\ is record
        output : \GpioRegisters.output.output_storage_t\;
    end record;

    type field_storage_t is record
        direction : \GpioRegisters.direction_storage_t\;
        output : \GpioRegisters.output_storage_t\;
    end record;
    signal field_storage : field_storage_t;

    ----------------------------------------------------------------------------
    -- Readback Signals
    ----------------------------------------------------------------------------
    signal readback_err : std_logic;
    signal readback_done : std_logic;
    signal readback_data : std_logic_vector(31 downto 0);
    signal readback_array : std_logic_vector_array1(0 to 2)(31 downto 0);

begin

    ----------------------------------------------------------------------------
    -- CPU Bus interface
    ----------------------------------------------------------------------------
    -- pragma translate_off
    cpuif_generics: process begin
        assert_bad_addr_width: assert s_axil_i.ARADDR'length >= GPIOREGISTERS_MIN_ADDR_WIDTH
            report "Interface address width of " & integer'image(s_axil_i.ARADDR'length) & " is too small. Shall be at least " & integer'image(GPIOREGISTERS_MIN_ADDR_WIDTH) & " bits"
            severity failure;
        assert_bad_data_width: assert s_axil_i.WDATA'length = GPIOREGISTERS_DATA_WIDTH
            report "Interface data width of " & integer'image(s_axil_i.WDATA'length) & " is incorrect. Shall be " & integer'image(GPIOREGISTERS_DATA_WIDTH) & " bits"
            severity failure;
        wait;
    end process;
    -- pragma translate_on


    -- Max Outstanding Transactions: 2
    -- Transaction request acceptance
    process(clk) begin
        if false then -- async reset
            axil_prev_was_rd <= '0';
            axil_arvalid <= '0';
            axil_araddr <= (others => '0');
            axil_awvalid <= '0';
            axil_awaddr <= (others => '0');
            axil_wvalid <= '0';
            axil_wdata <= (others => '0');
            axil_wstrb <= (others => '0');
            axil_n_in_flight <= (others => '0');
        elsif rising_edge(clk) then
            if rst then -- sync reset
                axil_prev_was_rd <= '0';
                axil_arvalid <= '0';
                axil_araddr <= (others => '0');
                axil_awvalid <= '0';
                axil_awaddr <= (others => '0');
                axil_wvalid <= '0';
                axil_wdata <= (others => '0');
                axil_wstrb <= (others => '0');
                axil_n_in_flight <= (others => '0');
            else
                -- AR* acceptance register
                if axil_ar_accept then
                    axil_prev_was_rd <= '1';
                    axil_arvalid <= '0';
                end if;
                if s_axil_i.ARVALID and s_axil_o.ARREADY then
                    axil_arvalid <= '1';
                    axil_araddr <= s_axil_i.ARADDR;
                end if;

                -- AW* & W* acceptance registers
                if axil_aw_accept  then
                    axil_prev_was_rd <= '0';
                    axil_awvalid <= '0';
                    axil_wvalid <= '0';
                end if;
                if s_axil_i.AWVALID and s_axil_o.AWREADY then
                    axil_awvalid <= '1';
                    axil_awaddr <= s_axil_i.AWADDR;
                end if;
                if s_axil_i.WVALID and s_axil_o.WREADY then
                    axil_wvalid <= '1';
                    axil_wdata <= s_axil_i.WDATA;
                    axil_wstrb <= s_axil_i.WSTRB;
                end if;

                -- Keep track of in-flight transactions
                if (axil_ar_accept or axil_aw_accept) and not axil_resp_acked then
                    axil_n_in_flight <= axil_n_in_flight + 1;
                elsif not (axil_ar_accept or axil_aw_accept) and axil_resp_acked then
                    axil_n_in_flight <= axil_n_in_flight - 1;
                end if;
            end if;
        end if;
    end process;

    process(all) begin
        s_axil_o.ARREADY <= not axil_arvalid or axil_ar_accept;
        s_axil_o.AWREADY <= not axil_awvalid or axil_aw_accept;
        s_axil_o.WREADY <= not axil_wvalid or axil_aw_accept;
    end process;

    -- Request dispatch
    process(all) begin
        cpuif_wr_data <= axil_wdata;
        for i in axil_wstrb'RANGE loop
            cpuif_wr_biten(i*8 + 7 downto i*8) <= (others => axil_wstrb(i));
        end loop;
        cpuif_req <= '0';
        cpuif_req_is_wr <= '0';
        cpuif_addr <= (others => '0');
        axil_ar_accept <= '0';
        axil_aw_accept <= '0';

        if axil_n_in_flight < to_unsigned(2, 2) then
            -- Can safely issue more transactions without overwhelming response buffer
            if axil_arvalid and not axil_prev_was_rd then
                cpuif_req <= '1';
                cpuif_req_is_wr <= '0';
                cpuif_addr <= (3 downto 2 => axil_araddr(3 downto 2), others => '0');
                if not cpuif_req_stall_rd then
                    axil_ar_accept <= '1';
                end if;
            elsif axil_awvalid and axil_wvalid then
                cpuif_req <= '1';
                cpuif_req_is_wr <= '1';
                cpuif_addr <= (3 downto 2 => axil_awaddr(3 downto 2), others => '0');
                if not cpuif_req_stall_wr then
                    axil_aw_accept <= '1';
                end if;
            elsif axil_arvalid then
                cpuif_req <= '1';
                cpuif_req_is_wr <= '0';
                cpuif_addr <= (3 downto 2 => axil_araddr(3 downto 2), others => '0');
                if not cpuif_req_stall_rd then
                    axil_ar_accept <= '1';
                end if;
            end if;
        end if;
    end process;
    -- AXI4-Lite Response Logic
    process(clk) begin
        if false then -- async reset
            for i in axil_resp_buffer'RANGE loop
                axil_resp_buffer(i).is_wr <= '0';
                axil_resp_buffer(i).err <= '0';
                axil_resp_buffer(i).rdata <= (others => '0');
            end loop;
            axil_resp_wptr <= (others => '0');
            axil_resp_rptr <= (others => '0');
        elsif rising_edge(clk) then
            if rst then -- sync reset
                for i in axil_resp_buffer'RANGE loop
                    axil_resp_buffer(i).is_wr <= '0';
                    axil_resp_buffer(i).err <= '0';
                    axil_resp_buffer(i).rdata <= (others => '0');
                end loop;
                axil_resp_wptr <= (others => '0');
                axil_resp_rptr <= (others => '0');
            else
                -- Store responses in buffer until AXI response channel accepts them
                if cpuif_rd_ack or cpuif_wr_ack then
                    if cpuif_rd_ack then
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).is_wr <= '0';
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).err <= cpuif_rd_err;
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).rdata <= cpuif_rd_data;

                    elsif cpuif_wr_ack then
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).is_wr <= '1';
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).err <= cpuif_wr_err;
                    end if;
                    axil_resp_wptr <= axil_resp_wptr + 1;
                end if;

                -- Advance read pointer when acknowledged
                if axil_resp_acked then
                    axil_resp_rptr <= axil_resp_rptr + 1;
                end if;
            end if;
        end if;
    end process;

    process(all) begin
        axil_resp_acked <= '0';
        s_axil_o.BVALID <= '0';
        s_axil_o.RVALID <= '0';
        if axil_resp_rptr /= axil_resp_wptr then
            if axil_resp_buffer(to_integer(axil_resp_rptr(0 downto 0))).is_wr then
                s_axil_o.BVALID <= '1';
                if s_axil_i.BREADY then
                    axil_resp_acked <= '1';
                end if;
            else
                s_axil_o.RVALID <= '1';
                if s_axil_i.RREADY then
                    axil_resp_acked <= '1';
                end if;
            end if;
        end if;

        s_axil_o.RDATA <= axil_resp_buffer(to_integer(axil_resp_rptr(0 downto 0))).rdata;
        if axil_resp_buffer(to_integer(axil_resp_rptr(0 downto 0))).err then
            s_axil_o.BRESP <= "10";
            s_axil_o.RRESP <= "10";
        else
            s_axil_o.BRESP <= "00";
            s_axil_o.RRESP <= "00";
        end if;
    end process;

    -- Read & write latencies are balanced. Stalls not required
    cpuif_req_stall_rd <= '0';
    cpuif_req_stall_wr <= '0';
    cpuif_req_masked <= cpuif_req
                        and not (not cpuif_req_is_wr and cpuif_req_stall_rd)
                        and not (cpuif_req_is_wr and cpuif_req_stall_wr);

    ----------------------------------------------------------------------------
    -- Address Decode
    ----------------------------------------------------------------------------
    process(all)
        -- overload "=" in this scope to avoid lots of type casts
        function "="(L: std_logic_vector; R: integer) return std_logic is
            variable result : std_logic;
        begin
            result := '1' when unsigned(L) = R else '0';
            return result;
        end;
        variable is_valid_addr : std_logic;
        variable is_invalid_rw : std_logic;
    begin
        is_valid_addr := '1'; -- No error checking on valid address access
        is_invalid_rw := '0';
        decoded_reg_strb.direction <= cpuif_req_masked and (cpuif_addr = 16#0#);
        decoded_reg_strb.output <= cpuif_req_masked and (cpuif_addr = 16#4#);
        decoded_reg_strb.input <= cpuif_req_masked and (cpuif_addr = 16#8#) and not cpuif_req_is_wr;
        decoded_err <= (not is_valid_addr or is_invalid_rw) and decoded_req;
    end process;

    -- Pass down signals to next stage
    process(all) begin
        decoded_req <= cpuif_req_masked;
        decoded_req_is_wr <= cpuif_req_is_wr;
        decoded_wr_data <= cpuif_wr_data;
        decoded_wr_biten <= cpuif_wr_biten;
    end process;

    ----------------------------------------------------------------------------
    -- Field logic
    ----------------------------------------------------------------------------
    
    -- Field: GpioRegisters.direction.direction
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.direction.direction.value;
        load_next_c := '0';
        if decoded_reg_strb.direction and decoded_req_is_wr then -- SW write
            next_c := (field_storage.direction.direction.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.direction.direction.next_q <= next_c;
        field_combo.direction.direction.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.direction.direction.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.direction.direction.value <= 32x"0";
            else
                if field_combo.direction.direction.load_next then
                    field_storage.direction.direction.value <= field_combo.direction.direction.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.direction.direction.value <= field_storage.direction.direction.value;

    -- Field: GpioRegisters.output.output
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.output.output.value;
        load_next_c := '0';
        if decoded_reg_strb.output and decoded_req_is_wr then -- SW write
            next_c := (field_storage.output.output.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.output.output.next_q <= next_c;
        field_combo.output.output.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.output.output.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.output.output.value <= 32x"0";
            else
                if field_combo.output.output.load_next then
                    field_storage.output.output.value <= field_combo.output.output.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.output.output.value <= field_storage.output.output.value;

    ----------------------------------------------------------------------------
    -- Write response
    ----------------------------------------------------------------------------
    cpuif_wr_ack <= decoded_req and decoded_req_is_wr;
    -- Writes are always granted with no error response
    cpuif_wr_err <= '0';

    ----------------------------------------------------------------------------
    -- Readback
    ----------------------------------------------------------------------------

    -- Assign readback values to a flattened array
    readback_array(0)(31 downto 0) <= field_storage.direction.direction.value when (decoded_reg_strb.direction and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(31 downto 0) <= field_storage.output.output.value when (decoded_reg_strb.output and not decoded_req_is_wr) else (others => '0');
    readback_array(2)(31 downto 0) <= hwif_in.input.input.next_q when (decoded_reg_strb.input and not decoded_req_is_wr) else (others => '0');

    -- Reduce the array
    process(all)
        variable readback_data_var : std_logic_vector(31 downto 0) := (others => '0');
    begin
        readback_done <= decoded_req and not decoded_req_is_wr;
        readback_err <= '0';
        readback_data_var := (others => '0');
        for i in readback_array'RANGE loop
            readback_data_var := readback_data_var or readback_array(i);
        end loop;
        readback_data <= readback_data_var;
    end process;

    cpuif_rd_ack <= readback_done;
    cpuif_rd_data <= readback_data;
    cpuif_rd_err <= readback_err;
end architecture rtl;
